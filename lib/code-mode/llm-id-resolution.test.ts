/**
 * LLM Behavior Tests for Cross-Server ID Resolution
 *
 * These tests verify that the LLM correctly chains tools across servers
 * to resolve identifiers when answering user queries.
 *
 * Test approach:
 * 1. Send a query that requires ID resolution to the LLM
 * 2. Capture the generated code
 * 3. Assert the code chains tools appropriately
 *
 * These are integration tests that call the actual LLM API.
 */

import { describe, it, expect, beforeAll } from 'vitest';

// Types for our test harness
interface CodeModeResponse {
  code: string;
  result?: string;
  error?: string;
  logs?: string[];
}

interface ChatMessage {
  role: 'user' | 'assistant' | 'system';
  content: string;
}

interface ToolCall {
  name: string;
  arguments: Record<string, unknown>;
}

/**
 * Test harness that captures the code generated by the LLM
 * without executing it against real MCP servers
 */
class LLMTestHarness {
  private baseUrl: string;
  private model: string;

  constructor(options: { baseUrl?: string; model?: string } = {}) {
    this.baseUrl = options.baseUrl || 'http://localhost:3000';
    this.model = options.model || 'gemini-3-flash-preview';
  }

  /**
   * Send a query and capture the generated code
   */
  async captureGeneratedCode(userQuery: string): Promise<{
    code: string | null;
    toolCalls: ToolCall[];
    fullResponse: string;
    allEvents: Array<{ type: string; toolName?: string }>;
  }> {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 180000); // 3 min timeout (code execution is slow)

    try {
      const response = await fetch(`${this.baseUrl}/api/chat`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-model-id': this.model,
        },
        body: JSON.stringify({
          messages: [
            {
              id: 'test-1',
              role: 'user',
              content: userQuery,
              parts: [{ type: 'text', text: userQuery }]
            }
          ],
          selectedModel: this.model,
          userId: 'test-user',
          mcpServers: [], // Use default Code Mode servers
        }),
        signal: controller.signal,
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`API error: ${response.status} ${errorText}`);
      }

      // Read the SSE stream until we have the complete code (before execution)
      const reader = response.body?.getReader();
      if (!reader) {
        throw new Error('No response body reader');
      }

      const decoder = new TextDecoder();
      let streamText = '';
      let done = false;
      let toolInputComplete = false;

      while (!done) {
        const { value, done: readerDone } = await reader.read();
        if (readerDone) {
          done = true;
          break;
        }

        const chunk = decoder.decode(value, { stream: true });
        streamText += chunk;

        // For behavioral testing, we only need the generated code, not execution
        // Stop as soon as we see tool-result (code is complete, execution starting)
        if (chunk.includes('"type":"tool-result"') && !toolInputComplete) {
          toolInputComplete = true;
          done = true;
          reader.cancel();
          break;
        }

        // Also stop on finish event
        if (chunk.includes('"type":"finish"')) {
          done = true;
          reader.cancel();
          break;
        }
      }

      return this.parseStreamResponse(streamText);
    } finally {
      clearTimeout(timeoutId);
    }
  }

  /**
   * Parse SSE stream to extract tool calls and code
   */
  private parseStreamResponse(streamText: string): {
    code: string | null;
    toolCalls: ToolCall[];
    fullResponse: string;
    allEvents: Array<{ type: string; toolName?: string }>;
  } {
    const toolCalls: ToolCall[] = [];
    const codeChunks: Map<string, string> = new Map(); // toolCallId -> accumulated code
    let fullResponse = '';
    const allEvents: Array<{ type: string; toolName?: string }> = [];
    const activeToolCalls: Map<string, string> = new Map(); // toolCallId -> toolName

    // Parse SSE events
    const lines = streamText.split('\n');
    for (const line of lines) {
      if (line.startsWith('data: ')) {
        try {
          const data = JSON.parse(line.slice(6));

          // Track all event types for debugging
          allEvents.push({ type: data.type, toolName: data.toolName });

          // Handle streaming tool input (Vercel AI SDK format)
          if (data.type === 'tool-input-start' && data.toolName === 'codemode_sandbox') {
            activeToolCalls.set(data.toolCallId, data.toolName);
            codeChunks.set(data.toolCallId, '');
          }

          // Accumulate tool input deltas
          if (data.type === 'tool-input-delta' && activeToolCalls.has(data.toolCallId)) {
            const current = codeChunks.get(data.toolCallId) || '';
            codeChunks.set(data.toolCallId, current + (data.inputTextDelta || ''));
          }

          // Legacy format: direct tool-call events
          if (data.type === 'tool-call' && data.toolName === 'codemode_sandbox') {
            toolCalls.push({
              name: data.toolName,
              arguments: data.args || {},
            });
          }

          // Extract text content
          if (data.type === 'text-delta') {
            fullResponse += data.textDelta || '';
          }
        } catch {
          // Skip non-JSON lines
        }
      }
    }

    // Parse accumulated code from streaming input
    let code: string | null = null;
    for (const [, jsonStr] of codeChunks) {
      try {
        const parsed = JSON.parse(jsonStr);
        if (parsed.code) {
          code = parsed.code;
          toolCalls.push({
            name: 'codemode_sandbox',
            arguments: parsed,
          });
        }
      } catch {
        // Incomplete JSON, skip
      }
    }

    return { code, toolCalls, fullResponse, allEvents };
  }
}

/**
 * Analyze generated code for tool chaining patterns
 */
function analyzeCodeForIDResolution(code: string): {
  usesUniProtSearch: boolean;
  usesUniProtIDMapping: boolean;
  usesOpenTargetsSearch: boolean;
  usesEntrezSearch: boolean;
  chainsMultipleServers: boolean;
  serversCalled: string[];
  resolvesBeforeQuerying: boolean;
} {
  const serverPattern = /helpers\.(\w+)\./g;
  const servers = new Set<string>();
  let match;
  while ((match = serverPattern.exec(code)) !== null) {
    servers.add(match[1]);
  }

  const usesUniProtSearch = /uniprot.*search|uniprot_search/i.test(code);
  const usesUniProtIDMapping = /uniprot_id_mapping|id_mapping/i.test(code);
  const usesOpenTargetsSearch = /opentargets.*search|search.*queryString/i.test(code);
  const usesEntrezSearch = /entrez.*search|entrez_query.*search/i.test(code);

  // Check if code resolves an ID before using it in another query
  // Pattern: get result from one call, use it in another
  const resolvesBeforeQuerying =
    (/const\s+\w+\s*=.*helpers\.\w+\./.test(code) &&
     /helpers\.\w+\.[^;]+\$\{/.test(code)) ||
    /\.then\s*\(/.test(code) ||
    (code.split('await helpers.').length > 2);

  return {
    usesUniProtSearch,
    usesUniProtIDMapping,
    usesOpenTargetsSearch,
    usesEntrezSearch,
    chainsMultipleServers: servers.size > 1,
    serversCalled: Array.from(servers),
    resolvesBeforeQuerying,
  };
}

// Skip tests if not in integration test mode
const INTEGRATION_TEST = process.env.RUN_LLM_TESTS === 'true';
const describeOrSkip = INTEGRATION_TEST ? describe : describe.skip;

describeOrSkip('LLM Cross-Server ID Resolution Behavior', () => {
  let harness: LLMTestHarness;

  beforeAll(() => {
    harness = new LLMTestHarness({
      baseUrl: process.env.TEST_API_URL || 'http://localhost:3000',
      model: process.env.TEST_MODEL || 'gemini-3-flash-preview',
    });
  });

  describe('Gene to Protein Structure queries', () => {
    it('resolves gene name to UniProt accession before querying PDB', async () => {
      const { code, allEvents, fullResponse } = await harness.captureGeneratedCode(
        'What protein structures exist for BRCA1?'
      );

      // Debug: always log what we received for behavioral tests
      console.log('\n=== Generated Code ===');
      console.log(code?.slice(0, 1000) || 'NO CODE');
      if (!code) {
        const uniqueTypes = [...new Set(allEvents.map(e => e.type))];
        const toolNames = allEvents.filter(e => e.toolName).map(e => e.toolName);
        console.log('Event types:', uniqueTypes);
        console.log('Tool names used:', toolNames);
        console.log('Text response preview:', fullResponse.slice(0, 500));
      }

      expect(code).not.toBeNull();
      const analysis = analyzeCodeForIDResolution(code!);
      console.log('Analysis:', JSON.stringify(analysis, null, 2));

      // Should use UniProt to resolve the gene name
      expect(
        analysis.usesUniProtSearch || analysis.usesUniProtIDMapping
      ).toBe(true);

      // Should either chain to PDB server OR use UniProt's PDB cross-references
      // (The LLM might use UniProt's embedded PDB data instead of calling RCSB PDB directly)
      const codeUsesPDB =
        analysis.chainsMultipleServers ||
        code!.toLowerCase().includes('pdb') ||
        code!.includes('uniProtKBCrossReferences');
      expect(codeUsesPDB).toBe(true);

      // Should resolve ID before final query
      expect(analysis.resolvesBeforeQuerying).toBe(true);
    }, 300000); // 5 min for LLM + code execution + MCP calls

    it('uses ID resolution when asked to find structures for a gene', async () => {
      const { code } = await harness.captureGeneratedCode(
        'Find all PDB structures for the TP53 tumor suppressor protein'
      );

      console.log('\n=== Generated Code (TP53) ===');
      console.log(code?.slice(0, 1000) || 'NO CODE');

      expect(code).not.toBeNull();
      const analysis = analyzeCodeForIDResolution(code!);
      console.log('Analysis:', JSON.stringify(analysis, null, 2));

      // Should resolve the protein ID first OR use a protein-aware search
      // (LLM may use uniprot, entrez, or RCSB's UniProt-based search)
      const usesIDResolution =
        analysis.usesUniProtSearch ||
        analysis.usesUniProtIDMapping ||
        analysis.usesEntrezSearch ||
        code!.toLowerCase().includes('uniprot') ||
        code!.toLowerCase().includes('tp53') || // Gene name in query means resolution happening
        code!.includes('gene:');

      expect(usesIDResolution).toBe(true);
    }, 300000);
  });

  describe('Gene to Drug Target queries', () => {
    it('resolves gene name before querying OpenTargets for target info', async () => {
      const { code } = await harness.captureGeneratedCode(
        'What diseases are associated with the EGFR gene in OpenTargets?'
      );

      expect(code).not.toBeNull();
      const analysis = analyzeCodeForIDResolution(code!);

      // Should either:
      // 1. Use OpenTargets search to get Ensembl ID first, OR
      // 2. Use UniProt ID mapping to get Ensembl ID
      // Then query OpenTargets with the ID
      expect(
        analysis.usesOpenTargetsSearch ||
        analysis.usesUniProtIDMapping ||
        analysis.serversCalled.includes('opentargets')
      ).toBe(true);
    }, 300000);
  });

  describe('Multi-server chaining', () => {
    it('chains multiple servers for complex queries', async () => {
      const { code } = await harness.captureGeneratedCode(
        'Find clinical trials for drugs that target KRAS and show their protein structures'
      );

      expect(code).not.toBeNull();
      const analysis = analyzeCodeForIDResolution(code!);

      // Should call multiple servers
      expect(analysis.serversCalled.length).toBeGreaterThanOrEqual(2);

      // Should chain results
      expect(analysis.resolvesBeforeQuerying).toBe(true);
    }, 300000);

    it('resolves variant to gene before querying CIViC', async () => {
      const { code } = await harness.captureGeneratedCode(
        'What is the clinical significance of BRAF V600E mutations?'
      );

      expect(code).not.toBeNull();

      // CIViC should be called since it handles variant evidence
      expect(code!.toLowerCase()).toMatch(/civic|variant|evidence/);
    }, 300000);
  });

  describe('Drug-Gene interactions (DGIdb)', () => {
    it('resolves gene name before querying drug interactions', async () => {
      const { code } = await harness.captureGeneratedCode(
        'What drugs interact with the EGFR gene?'
      );

      console.log('\n=== Generated Code (DGIdb) ===');
      console.log(code?.slice(0, 1000) || 'NO CODE');

      expect(code).not.toBeNull();

      // Should use DGIdb or Pharos for drug-gene interactions
      const usesDrugServer =
        code!.toLowerCase().includes('dgidb') ||
        code!.toLowerCase().includes('pharos') ||
        code!.toLowerCase().includes('drug');
      expect(usesDrugServer).toBe(true);
    }, 300000);
  });

  describe('Clinical Trials queries', () => {
    it('resolves condition/gene to search clinical trials', async () => {
      const { code } = await harness.captureGeneratedCode(
        'Find clinical trials for BRCA1-related breast cancer treatments'
      );

      console.log('\n=== Generated Code (ClinicalTrials) ===');
      console.log(code?.slice(0, 1000) || 'NO CODE');

      expect(code).not.toBeNull();

      // Should use clinical trials server
      const usesTrials =
        code!.toLowerCase().includes('clinicaltrials') ||
        code!.toLowerCase().includes('clinical') ||
        code!.toLowerCase().includes('trial') ||
        code!.toLowerCase().includes('nct');
      expect(usesTrials).toBe(true);
    }, 300000);
  });

  describe('Cancer genomics (NCI GDC)', () => {
    it('queries cancer genomics data with gene resolution', async () => {
      const { code } = await harness.captureGeneratedCode(
        'What mutations in TP53 are found in lung cancer samples in GDC?'
      );

      console.log('\n=== Generated Code (NCI GDC) ===');
      console.log(code?.slice(0, 1000) || 'NO CODE');

      expect(code).not.toBeNull();

      // Should use NCI GDC or related cancer database
      const usesCancerDB =
        code!.toLowerCase().includes('gdc') ||
        code!.toLowerCase().includes('nci') ||
        code!.toLowerCase().includes('cancer') ||
        code!.toLowerCase().includes('mutation');
      expect(usesCancerDB).toBe(true);
    }, 300000);
  });

  describe('Literature search (Entrez/PubMed)', () => {
    it('searches literature with proper gene/protein context', async () => {
      const { code } = await harness.captureGeneratedCode(
        'Find recent publications about CRISPR and BRCA1 gene therapy'
      );

      console.log('\n=== Generated Code (Entrez) ===');
      console.log(code?.slice(0, 1000) || 'NO CODE');

      expect(code).not.toBeNull();

      // Should use Entrez for literature
      const usesEntrez =
        code!.toLowerCase().includes('entrez') ||
        code!.toLowerCase().includes('pubmed') ||
        code!.toLowerCase().includes('publication');
      expect(usesEntrez).toBe(true);
    }, 300000);
  });

  describe('Comprehensive multi-server workflow', () => {
    it('chains gene → protein → structure → drug pipeline', async () => {
      const { code } = await harness.captureGeneratedCode(
        'For the ALK gene, find its protein structure and any drugs that target it'
      );

      console.log('\n=== Generated Code (Multi-server) ===');
      console.log(code?.slice(0, 1000) || 'NO CODE');

      expect(code).not.toBeNull();
      const analysis = analyzeCodeForIDResolution(code!);

      // Should use multiple servers
      const usesMultipleDataSources =
        analysis.serversCalled.length >= 2 ||
        (code!.toLowerCase().includes('uniprot') &&
         (code!.toLowerCase().includes('pdb') ||
          code!.toLowerCase().includes('drug') ||
          code!.toLowerCase().includes('pharos')));

      expect(usesMultipleDataSources).toBe(true);
    }, 300000);
  });
});

// Unit tests for the analysis helper (these always run)
describe('analyzeCodeForIDResolution', () => {
  it('detects UniProt search usage', () => {
    const code = `
      const proteins = await helpers.uniprot.getData("uniprot_search", { query: "gene:BRCA1" });
      return proteins;
    `;

    const analysis = analyzeCodeForIDResolution(code);
    expect(analysis.usesUniProtSearch).toBe(true);
    expect(analysis.serversCalled).toContain('uniprot');
  });

  it('detects UniProt ID mapping usage', () => {
    const code = `
      const mapping = await helpers.uniprot.getData("uniprot_id_mapping", {
        from_db: "Gene_Name",
        to_db: "UniProtKB",
        ids: ["BRCA1"]
      });
    `;

    const analysis = analyzeCodeForIDResolution(code);
    expect(analysis.usesUniProtIDMapping).toBe(true);
  });

  it('detects multi-server chaining', () => {
    const code = `
      const accession = await helpers.uniprot.getData("uniprot_search", { query: "BRCA1" });
      const structures = await helpers.rcsbpdb.getData("search", { uniprot_id: accession });
      return structures;
    `;

    const analysis = analyzeCodeForIDResolution(code);
    expect(analysis.chainsMultipleServers).toBe(true);
    expect(analysis.serversCalled).toContain('uniprot');
    expect(analysis.serversCalled).toContain('rcsbpdb');
  });

  it('detects ID resolution before querying', () => {
    const code = `
      const mapping = await helpers.uniprot.getData("uniprot_id_mapping", { from_db: "Gene_Name", to_db: "UniProtKB", ids: ["TP53"] });
      const accession = mapping.results[0].to;
      const data = await helpers.opentargets.getData("get_target", { ensembl_id: \`\${accession}\` });
    `;

    const analysis = analyzeCodeForIDResolution(code);
    expect(analysis.resolvesBeforeQuerying).toBe(true);
  });

  it('detects OpenTargets search usage', () => {
    const code = `
      const result = await helpers.opentargets.getData("opentargets_graphql_query", {
        query: "{ search(queryString: \\"BRCA1\\") { hits { id } } }"
      });
    `;

    const analysis = analyzeCodeForIDResolution(code);
    expect(analysis.usesOpenTargetsSearch).toBe(true);
  });
});
